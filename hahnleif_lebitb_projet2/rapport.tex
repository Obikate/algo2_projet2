\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
%% \usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage{graphicx}

\title{Files de priorités, Arbres de Huffman}
\author{Hahnlein Felix, Lebit Benjamin}
\date{Mai 2015}

\begin{document}

\maketitle

\section{Avancement du projet et structure de l'archive}
Le code final fourni implémente toutes les optimisations décritent dans le sujet excepté la dernière (découpage des fichiers textes originaux en fichiers tampons pour rendre l'arbre de Huffman plus compact). \\\\
L'archive du projet est constituée de 4 dossiers principaux et d'un Makefile dont nous détaillerons l'utilisation ci-après :
\begin{itemize}
\item Le dossier \textit{fichiers\_compresses} contenant les versions compressées de chaque fichier texte de test du dossier \textit{tests}.
\item Le dossier \textit{resultats} contenant, aprés compilation, les fichiers de test décompressés et un fichier \textit{resultats.txt}, généré par le script du fichier\textit{ script\_tests.sh}, contenant des données d'expérimentation des différents fichiers textes (ces résultats seront explicités dans la section 3)
\item Le dossier \textit{src} contenant le code source. Les fichiers \textit{arbre\_huffman.adb/ads} et \textit{huffman.adb} ont 3 versions en fonction de l'état du code (sans optimmisation, avec décodage code ou version finale).
\item le dossier \textit{tests} contenant tous les fichiers textes au format .txt utilisés pour les tests.
\end{itemize}
La compilation de l'archive se fera en lançant la commande \scriptsize{\textbf{\$make all}} \normalsize{ et la décompilation avec la commande }\scriptsize{\textbf{\$make clean}}.
\section{Détails de l'implémentation}
	La structure générale du compresseur était déjà imposée, alors on va juste expliquer les choix qu'on a fait lors de l'implémentation.
	\begin{enumerate}
		\item{File de priorité}\\
			Nous avons opté pour une représentation par un tas en utilisant un type d'enregistrement. \\
			Tout au long de son utilisation, nous avons besoin du nombre courant d'éléments qui se trouvent dans la file. On peut donc soit utiliser une variable globale résidant dans le fichier \verb+file_priorite.adb+ soit déclarer la file comme un type d'enregistrement. Pour ne pas avoir des effets de bords, nous avons choisi un type d'enregistrement.\\
			L'implémentation des fonctions gérant la file est classique, tout en respectant qu'ici nous avons besoin de l'élément le moins prioritaire en "haut" du tas. Il s'agit donc d'une file de priorité "inversée".
		\item{Affichage de l'arbre}\\
			En pratique, l'arbre de Huffman sera trop encombrant pour bien l'afficher sur la sortie standard. Ainsi, on a choisi un affichage rudimentaire qui représente les n\oe{}uds sous forme des $0$ et dès qu'on tombe sur une feuille, il affiche le caractère correspondant. Cet affichage ne sert qu'au débogage.
		\item{Calcul de l'arbre}
			On a utilisé l'algorithme classique pour la construction récursive de l'arbre de Huffman, i.e. on fusionne à chaque itération les deux n\oe{}uds qui ont la probabilité la plus petite jusqu'à ce qu'il ne reste qu'un seul n\oe{}ud.
		\item{Calcul du dictionnaire}
			Le code associé à un caractère s'obtient en parcourant l'arbre et en se souvenant à chaque branchement de la direction (gauche ou droite) choisie.\\
			Ici, on a rencontré l'obstacle suivant: on ne connait pas d'avance la longueur du code. Or, le code sera stocké dans un tableau dont la déclaration nécessite cette information.\\
			Pour contourner ce problème, on pourrait effectuer une recherche d'élément dans l'arbre. Mais comme il n'existe pas de relation d'ordre dans l'arbre de Huffman, celle-ci serait en $\mathcal{O}(n)$.
	\end{enumerate}

\section{Tests de validation et d'expérimentation} 

\end{document}
